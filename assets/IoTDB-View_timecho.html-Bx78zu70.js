import{_ as t,c as r,b as s,d as a,e as i,a as o,w as l,r as d,o as c}from"./app-BHE9oQwv.js";const p={};function u(h,e){const n=d("RouteLink");return c(),r("div",null,[e[4]||(e[4]=s(`<h1 id="view" tabindex="-1"><a class="header-anchor" href="#view"><span>View</span></a></h1><h2 id="sequence-view-application-background" tabindex="-1"><a class="header-anchor" href="#sequence-view-application-background"><span>Sequence View Application Background</span></a></h2><h2 id="application-scenario-1-time-series-renaming-pi-asset-management" tabindex="-1"><a class="header-anchor" href="#application-scenario-1-time-series-renaming-pi-asset-management"><span>Application Scenario 1 Time Series Renaming (PI Asset Management)</span></a></h2><p>In practice, the equipment collecting data may be named with identification numbers that are difficult to be understood by human beings, which brings difficulties in querying to the business layer.</p><p>The Sequence View, on the other hand, is able to re-organise the management of these sequences and access them using a new model structure without changing the original sequence content and without the need to create new or copy sequences.</p><p><strong>For example</strong>: a cloud device uses its own NIC MAC address to form entity numbers and stores data by writing the following time sequence:<code>root.db.0800200A8C6D.xvjeifg</code>.</p><p>It is difficult for the user to understand. However, at this point, the user is able to rename it using the sequence view feature, map it to a sequence view, and use <code>root.view.device001.temperature</code> to access the captured data.</p><h3 id="application-scenario-2-simplifying-business-layer-query-logic" tabindex="-1"><a class="header-anchor" href="#application-scenario-2-simplifying-business-layer-query-logic"><span>Application Scenario 2 Simplifying business layer query logic</span></a></h3><p>Sometimes users have a large number of devices that manage a large number of time series. When conducting a certain business, the user wants to deal with only some of these sequences. At this time, the focus of attention can be picked out by the sequence view function, which is convenient for repeated querying and writing.</p><p><strong>For example</strong>: Users manage a product assembly line with a large number of time series for each segment of the equipment. The temperature inspector only needs to focus on the temperature of the equipment, so he can extract the temperature-related sequences and compose the sequence view.</p><h3 id="application-scenario-3-auxiliary-rights-management" tabindex="-1"><a class="header-anchor" href="#application-scenario-3-auxiliary-rights-management"><span>Application Scenario 3 Auxiliary Rights Management</span></a></h3><p>In the production process, different operations are generally responsible for different scopes. For security reasons, it is often necessary to restrict the access scope of the operations staff through permission management.</p><p><strong>For example</strong>: The safety management department now only needs to monitor the temperature of each device in a production line, but these data are stored in the same database with other confidential data. At this point, it is possible to create a number of new views that contain only temperature-related time series on the production line, and then to give the security officer access to only these sequence views, thus achieving the purpose of permission restriction.</p><h3 id="motivation-for-designing-sequence-view-functionality" tabindex="-1"><a class="header-anchor" href="#motivation-for-designing-sequence-view-functionality"><span>Motivation for designing sequence view functionality</span></a></h3><p>Combining the above two types of usage scenarios, the motivations for designing sequence view functionality, are:</p><ol><li>time series renaming.</li><li>to simplify the query logic at the business level.</li><li>Auxiliary rights management, open data to specific users through the view.</li></ol><h2 id="sequence-view-concepts" tabindex="-1"><a class="header-anchor" href="#sequence-view-concepts"><span>Sequence View Concepts</span></a></h2><h3 id="terminology-concepts" tabindex="-1"><a class="header-anchor" href="#terminology-concepts"><span>Terminology Concepts</span></a></h3><p>Concept: If not specified, the views specified in this document are <strong>Sequence Views</strong>, and new features such as device views may be introduced in the future.</p><h3 id="sequence-view" tabindex="-1"><a class="header-anchor" href="#sequence-view"><span>Sequence view</span></a></h3><p>A sequence view is a way of organising the management of time series.</p><p>In traditional relational databases, data must all be stored in a table, whereas in time series databases such as IoTDB, it is the sequence that is the storage unit. Therefore, the concept of sequence views in IoTDB is also built on sequences.</p><p>A sequence view is a virtual time series, and each virtual time series is like a soft link or shortcut that maps to a sequence or some kind of computational logic external to a certain view. In other words, a virtual sequence either maps to some defined external sequence or is computed from multiple external sequences.</p><p>Users can create views using complex SQL queries, where the sequence view acts as a stored query statement, and when data is read from the view, the stored query statement is used as the source of the data in the FROM clause.</p><h3 id="alias-sequences" tabindex="-1"><a class="header-anchor" href="#alias-sequences"><span>Alias Sequences</span></a></h3><p>There is a special class of beings in a sequence view that satisfy all of the following conditions:</p><ol><li>the data source is a single time series</li><li>there is no computational logic</li><li>no filtering conditions (e.g., no WHERE clause restrictions).</li></ol><p>Such a sequence view is called an <strong>alias sequence</strong>, or alias sequence view. A sequence view that does not fully satisfy all of the above conditions is called a non-alias sequence view. The difference between them is that only aliased sequences support write functionality.</p><p>** All sequence views, including aliased sequences, do not currently support Trigger functionality. **</p><h3 id="nested-views" tabindex="-1"><a class="header-anchor" href="#nested-views"><span>Nested Views</span></a></h3><p>A user may want to select a number of sequences from an existing sequence view to form a new sequence view, called a nested view.</p><p><strong>The current version does not support the nested view feature</strong>.</p><h3 id="some-constraints-on-sequence-views-in-iotdb" tabindex="-1"><a class="header-anchor" href="#some-constraints-on-sequence-views-in-iotdb"><span>Some constraints on sequence views in IoTDB</span></a></h3><h4 id="constraint-1-a-sequence-view-must-depend-on-one-or-several-time-series" tabindex="-1"><a class="header-anchor" href="#constraint-1-a-sequence-view-must-depend-on-one-or-several-time-series"><span>Constraint 1 A sequence view must depend on one or several time series</span></a></h4><p>A sequence view has two possible forms of existence:</p><ol><li>it maps to a time series</li><li>it is computed from one or more time series.</li></ol><p>The former form of existence has been exemplified in the previous section and is easy to understand; the latter form of existence here is because the sequence view allows for computational logic.</p><p>For example, the user has installed two thermometers in the same boiler and now needs to calculate the average of the two temperature values as a measurement. The user has captured the following two sequences: <code>root.db.d01.temperature01</code>, <code>root.db.d01.temperature02</code>.</p><p>At this point, the user can use the average of the two sequences as one sequence in the view: <code>root.db.d01.avg_temperature</code>.</p><p>This example will 3.1.2 expand in detail.</p><h4 id="restriction-2-non-alias-sequence-views-are-read-only" tabindex="-1"><a class="header-anchor" href="#restriction-2-non-alias-sequence-views-are-read-only"><span>Restriction 2 Non-alias sequence views are read-only</span></a></h4><p>Writing to non-alias sequence views is not allowed.</p><p>Only aliased sequence views are supported for writing.</p><h4 id="restriction-3-nested-views-are-not-allowed" tabindex="-1"><a class="header-anchor" href="#restriction-3-nested-views-are-not-allowed"><span>Restriction 3 Nested views are not allowed</span></a></h4><p>It is not possible to select certain columns in an existing sequence view to create a sequence view, either directly or indirectly.</p><p>An example of this restriction will be given in 3.1.3.</p><h4 id="restriction-4-sequence-view-and-time-series-cannot-be-renamed" tabindex="-1"><a class="header-anchor" href="#restriction-4-sequence-view-and-time-series-cannot-be-renamed"><span>Restriction 4 Sequence view and time series cannot be renamed</span></a></h4><p>Both sequence views and time series are located under the same tree, so they cannot be renamed.</p><p>The name (path) of any sequence should be uniquely determined.</p><h4 id="restriction-5-sequence-views-share-timing-data-with-time-series-metadata-such-as-labels-are-not-shared" tabindex="-1"><a class="header-anchor" href="#restriction-5-sequence-views-share-timing-data-with-time-series-metadata-such-as-labels-are-not-shared"><span>Restriction 5 Sequence views share timing data with time series, metadata such as labels are not shared</span></a></h4><p>Sequence views are mappings pointing to time series, so they fully share timing data, with the time series being responsible for persistent storage.</p><p>However, their metadata such as tags and attributes are not shared.</p><p>This is because the business query, view-oriented users are concerned about the structure of the current view, and if you use group by tag and other ways to do the query, obviously want to get the view contains the corresponding tag grouping effect, rather than the time series of the tag grouping effect (the user is not even aware of those time series).</p><h2 id="sequence-view-functionality" tabindex="-1"><a class="header-anchor" href="#sequence-view-functionality"><span>Sequence view functionality</span></a></h2><h3 id="creating-a-view" tabindex="-1"><a class="header-anchor" href="#creating-a-view"><span>Creating a view</span></a></h3><p>Creating a sequence view is similar to creating a time series, the difference is that you need to specify the data source, i.e., the original sequence, through the AS keyword.</p><h4 id="sql-for-creating-a-view" tabindex="-1"><a class="header-anchor" href="#sql-for-creating-a-view"><span>SQL for creating a view</span></a></h4><p>User can select some sequences to create a view:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">CREATE VIEW root.view.device.status</span>
<span class="line">AS</span>
<span class="line">    SELECT s01  </span>
<span class="line">    FROM root.db.device</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>It indicates that the user has selected the sequence <code>s01</code> from the existing device <code>root.db.device</code>, creating the sequence view <code>root.view.device.status</code>.</p><p>The sequence view can exist under the same entity as the time series, for example:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">CREATE VIEW root.db.device.status</span>
<span class="line">AS</span>
<span class="line">    SELECT s01</span>
<span class="line">    FROM root.db.device</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Thus, there is a virtual copy of <code>s01</code> under <code>root.db.device</code>, but with a different name <code>status</code>.</p><p>It can be noticed that the sequence views in both of the above examples are aliased sequences, and we are giving the user a more convenient way of creating a sequence for that sequence:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">CREATE VIEW root.view.device.status</span>
<span class="line">AS</span>
<span class="line">    root.db.device.s01</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="creating-views-with-computational-logic" tabindex="-1"><a class="header-anchor" href="#creating-views-with-computational-logic"><span>Creating views with computational logic</span></a></h4><p>Following the example in section 2.2 Limitations 1:</p><blockquote><p>A user has installed two thermometers in the same boiler and now needs to calculate the average of the two temperature values as a measurement. The user has captured the following two sequences: <code>root.db.d01.temperature01</code>, <code>root.db.d01.temperature02</code>.</p><p>At this point, the user can use the two sequences averaged as one sequence in the view: <code>root.view.device01.avg_temperature</code>.</p></blockquote><p>If the view is not used, the user can query the average of the two temperatures like this:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">SELECT (temperature01 + temperature02) / 2</span>
<span class="line">FROM root.db.d01</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>And if using a sequence view, the user can create a view this way to simplify future queries:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">CREATE VIEW root.db.d01.avg_temperature</span>
<span class="line">AS</span>
<span class="line">    SELECT (temperature01 + temperature02) / 2</span>
<span class="line">    FROM root.db.d01</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The user can then query it like this:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">SELECT avg_temperature FROM root.db.d01</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="nested-sequence-views-not-supported" tabindex="-1"><a class="header-anchor" href="#nested-sequence-views-not-supported"><span>Nested sequence views not supported</span></a></h4><p>Continuing with the example from 3.1.2, the user now wants to create a new view using the sequence view <code>root.db.d01.avg_temperature</code>, which is not allowed. We currently do not support nested views, whether it is an aliased sequence or not.</p><p>For example, the following SQL statement will report an error:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">CREATE VIEW root.view.device.avg_temp_copy</span>
<span class="line">AS</span>
<span class="line">    root.db.d01.avg_temperature                        -- Not supported. Nested views are not allowed</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="creating-multiple-sequence-views-at-once" tabindex="-1"><a class="header-anchor" href="#creating-multiple-sequence-views-at-once"><span>Creating multiple sequence views at once</span></a></h4><p>If only one sequence view can be specified at a time which is not convenient for the user to use, then multiple sequences can be specified at a time, for example:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">CREATE VIEW root.db.device.status, root.db.device.sub.hardware</span>
<span class="line">AS</span>
<span class="line">    SELECT s01, s02</span>
<span class="line">    FROM root.db.device</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，上述写法可以做简化：</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">CREATE VIEW root.db.device(status, sub.hardware)</span>
<span class="line">AS</span>
<span class="line">    SELECT s01, s02</span>
<span class="line">    FROM root.db.device</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Both statements above are equivalent to the following typing:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">CREATE VIEW root.db.device.status</span>
<span class="line">AS</span>
<span class="line">    SELECT s01</span>
<span class="line">    FROM root.db.device;</span>
<span class="line"></span>
<span class="line">CREATE VIEW root.db.device.sub.hardware</span>
<span class="line">AS</span>
<span class="line">    SELECT s02</span>
<span class="line">    FROM root.db.device</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>is also equivalent to the following:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">CREATE VIEW root.db.device.status, root.db.device.sub.hardware</span>
<span class="line">AS</span>
<span class="line">    root.db.device.s01, root.db.device.s02</span>
<span class="line"></span>
<span class="line">-- or</span>
<span class="line"></span>
<span class="line">CREATE VIEW root.db.device(status, sub.hardware)</span>
<span class="line">AS</span>
<span class="line">    root.db.device(s01, s02)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="the-mapping-relationships-between-all-sequences-are-statically-stored" tabindex="-1"><a class="header-anchor" href="#the-mapping-relationships-between-all-sequences-are-statically-stored"><span>The mapping relationships between all sequences are statically stored</span></a></h5><p>Sometimes, the SELECT clause may contain a number of statements that can only be determined at runtime, such as below:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">SELECT s01, s02</span>
<span class="line">FROM root.db.d01, root.db.d02</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>The number of sequences that can be matched by the above statement is uncertain and is related to the state of the system. Even so, the user can use it to create views.</p><p>However, it is important to note that the mapping relationship between all sequences is stored statically (fixed at creation)! Consider the following example:</p><p>The current database contains only three sequences <code>root.db.d01.s01</code>, <code>root.db.d02.s01</code>, <code>root.db.d02.s02</code>, and then the view is created:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">CREATE VIEW root.view.d(alpha, beta, gamma)</span>
<span class="line">AS</span>
<span class="line">    SELECT s01, s02</span>
<span class="line">    FROM root.db.d01, root.db.d02</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The mapping relationship between time series is as follows:</p><table><thead><tr><th>sequence number</th><th>time series</th><th>sequence view</th></tr></thead><tbody><tr><td>1</td><td><code>root.db.d01.s01</code></td><td>root.view.d.alpha</td></tr><tr><td>2</td><td><code>root.db.d02.s01</code></td><td>root.view.d.beta</td></tr><tr><td>3</td><td><code>root.db.d02.s02</code></td><td>root.view.d.gamma</td></tr></tbody></table><p>After that, if the user adds the sequence <code>root.db.d01.s02</code>, it does not correspond to any view; then, if the user deletes <code>root.db.d01.s01</code>, the query for <code>root.view.d.alpha</code> will report an error directly, and it will not correspond to <code>root.db.d01.s02</code> either.</p><p>Please always note that inter-sequence mapping relationships are stored statically and solidly.</p><h4 id="batch-creation-of-sequence-views" tabindex="-1"><a class="header-anchor" href="#batch-creation-of-sequence-views"><span>Batch Creation of Sequence Views</span></a></h4><p>There are several existing devices, each with a temperature value, for example:</p><ol><li>root.db.d1.temperature</li><li>root.db.d2.temperature</li><li>...</li></ol><p>There may be many other sequences stored under these devices (e.g. <code>root.db.d1.speed</code>), but for now it is possible to create a view that contains only the temperature values for these devices, without relation to the other sequences:.</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">CREATE VIEW root.db.view(\${2}_temperature）</span>
<span class="line">AS</span>
<span class="line">    SELECT temperature FROM root.db.*</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,103)),a("p",null,[e[1]||(e[1]=i("This is modelled on the query writeback (")),e[2]||(e[2]=a("code",null,"SELECT INTO",-1)),e[3]||(e[3]=i(") convention for naming rules, which uses variable placeholders to specify naming rules. See also: ")),o(n,{to:"/UserGuide/V1.3.0-2/User-Manual/Query-Data.html#into-clause-query-write-back"},{default:l(()=>e[0]||(e[0]=[i("QUERY WRITEBACK (SELECT INTO)")])),_:1})]),e[5]||(e[5]=s(`<p>Here <code>root.db.*.temperature</code> specifies what time series will be included in the view; and <code>\${2}</code> specifies from which node in the time series the name is extracted to name the sequence view.</p><p>Here, <code>\${2}</code> refers to level 2 (starting at 0) of <code>root.db.*.temperature</code>, which is the result of the <code>*</code> match; and <code>\${2}_temperature</code> is the result of the match and <code>temperature</code> spliced together with underscores to make up the node names of the sequences under the view.</p><p>The above statement for creating a view is equivalent to the following writeup:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">CREATE VIEW root.db.view(\${2}_\${3}）</span>
<span class="line">AS</span>
<span class="line">    SELECT temperature from root.db.*</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The final view contains these sequences:</p><ol><li>root.db.view.d1_temperature</li><li>root.db.view.d2_temperature</li><li>...</li></ol><p>Created using wildcards, only static mapping relationships at the moment of creation will be stored.</p><h4 id="select-clauses-are-somewhat-limited-when-creating-views" tabindex="-1"><a class="header-anchor" href="#select-clauses-are-somewhat-limited-when-creating-views"><span>SELECT clauses are somewhat limited when creating views</span></a></h4><p>The SELECT clause used when creating a serial view is subject to certain restrictions. The main restrictions are as follows:</p><ol><li>the <code>WHERE</code> clause cannot be used.</li><li><code>GROUP BY</code> clause cannot be used.</li><li><code>MAX_VALUE</code> and other aggregation functions cannot be used.</li></ol><p>Simply put, after <code>AS</code> you can only use <code>SELECT ... FROM ... </code> and the results of this query must form a time series.</p><h3 id="view-data-queries" tabindex="-1"><a class="header-anchor" href="#view-data-queries"><span>View Data Queries</span></a></h3><p>For the data query functions that can be supported, the sequence view and time series can be used indiscriminately with identical behaviour when performing time series data queries.</p><p><strong>The types of queries that are not currently supported by the sequence view are as follows:</strong></p><ol><li>**align by device query</li><li>**group by tags query</li></ol><p>Users can also mix time series and sequence view queries in the same SELECT statement, for example:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">SELECT temperature01, temperature02, avg_temperature</span>
<span class="line">FROM root.db.d01</span>
<span class="line">WHERE temperature01 &lt; temperature02</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>However, if the user wants to query the metadata of the sequence, such as tag, attributes, etc., the query is the result of the sequence view, not the result of the time series referenced by the sequence view.</p><p>In addition, for aliased sequences, if the user wants to get information about the time series such as tags, attributes, etc., the user needs to query the mapping of the view columns to find the corresponding time series, and then query the time series for the tags, attributes, etc. The method of querying the mapping of the view columns will be explained in section 3.5.</p><h3 id="modify-views" tabindex="-1"><a class="header-anchor" href="#modify-views"><span>Modify Views</span></a></h3><p>Modifying a view, such as changing its name, modifying its calculation logic, deleting it, etc., is similar to creating a new view, in that you need to re-specify all the column descriptions for the entire view.</p><h4 id="modify-view-data-source" tabindex="-1"><a class="header-anchor" href="#modify-view-data-source"><span>Modify view data source</span></a></h4><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">ALTER VIEW root.view.device.status</span>
<span class="line">AS</span>
<span class="line">    SELECT s01</span>
<span class="line">    FROM root.ln.wf.d01</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="modify-the-view-s-calculation-logic" tabindex="-1"><a class="header-anchor" href="#modify-the-view-s-calculation-logic"><span>Modify the view&#39;s calculation logic</span></a></h4><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">ALTER VIEW root.db.d01.avg_temperature</span>
<span class="line">AS</span>
<span class="line">    SELECT (temperature01 + temperature02 + temperature03) / 3</span>
<span class="line">    FROM root.db.d01</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="tag-point-management" tabindex="-1"><a class="header-anchor" href="#tag-point-management"><span>Tag point management</span></a></h4><ul><li>Add a new<br> tag</li></ul><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">ALTER view root.turbine.d1.s1 ADD TAGS tag3=v3, tag4=v4</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>Add a new attribute</li></ul><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">ALTER view root.turbine.d1.s1 ADD ATTRIBUTES attr3=v3, attr4=v4</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>rename tag or attribute</li></ul><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">ALTER view root.turbine.d1.s1 RENAME tag1 TO newTag1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>Reset the value of a tag or attribute</li></ul><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">ALTER view root.turbine.d1.s1 SET newTag1=newV1, attr1=newV1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>Delete an existing tag or attribute</li></ul><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">ALTER view root.turbine.d1.s1 DROP tag1, tag2</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>Update insert aliases, tags and attributes</li></ul><blockquote><p>If the alias, tag or attribute did not exist before, insert it, otherwise, update the old value with the new one.</p></blockquote><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">ALTER view root.turbine.d1.s1 UPSERT TAGS(tag2=newV2, tag3=v3) ATTRIBUTES(attr3=v3, attr4=v4)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="deleting-views" tabindex="-1"><a class="header-anchor" href="#deleting-views"><span>Deleting Views</span></a></h4><p>Since a view is a sequence, a view can be deleted as if it were a time series.</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">DELETE VIEW root.view.device.avg_temperatue</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="view-synchronisation" tabindex="-1"><a class="header-anchor" href="#view-synchronisation"><span>View Synchronisation</span></a></h3><p>Sequence view data is always obtained via real-time queries, so data synchronisation is naturally supported.</p><h4 id="if-the-dependent-original-sequence-is-deleted" tabindex="-1"><a class="header-anchor" href="#if-the-dependent-original-sequence-is-deleted"><span>If the dependent original sequence is deleted</span></a></h4><p>When the sequence view is queried (when the sequence is parsed), <strong>the empty result set</strong> is returned if the dependent time series does not exist.</p><p>This is similar to the feedback for querying a non-existent sequence, but with a difference: if the dependent time series cannot be parsed, the empty result set is the one that contains the table header as a reminder to the user that the view is problematic.</p><p>Additionally, when the dependent time series is deleted, no attempt is made to find out if there is a view that depends on the column, and the user receives no warning.</p><h4 id="data-writes-to-non-aliased-sequences-not-supported" tabindex="-1"><a class="header-anchor" href="#data-writes-to-non-aliased-sequences-not-supported"><span>Data Writes to Non-Aliased Sequences Not Supported</span></a></h4><p>Writes to non-alias sequences are not supported.</p><p>Please refer to the previous section 2.1.6 Restrictions2 for more details.</p><h4 id="metadata-for-sequences-is-not-shared" tabindex="-1"><a class="header-anchor" href="#metadata-for-sequences-is-not-shared"><span>Metadata for sequences is not shared</span></a></h4><p>Please refer to the previous section 2.1.6 Restriction 5 for details.</p><h3 id="view-metadata-queries" tabindex="-1"><a class="header-anchor" href="#view-metadata-queries"><span>View Metadata Queries</span></a></h3><p>View metadata query specifically refers to querying the metadata of the view itself (e.g., how many columns the view has), as well as information about the views in the database (e.g., what views are available).</p><h4 id="viewing-current-view-columns" tabindex="-1"><a class="header-anchor" href="#viewing-current-view-columns"><span>Viewing Current View Columns</span></a></h4><p>The user has two ways of querying:</p><ol><li>a query using <code>SHOW TIMESERIES</code>, which contains both time series and series views. This query contains both the time series and the sequence view. However, only some of the attributes of the view can be displayed.</li><li>a query using <code>SHOW VIEW</code>, which contains only the sequence view. It displays the complete properties of the sequence view.</li></ol><p>Example:</p><div class="language-Shell line-numbers-mode" data-highlighter="prismjs" data-ext="Shell" data-title="Shell"><pre><code><span class="line">IoTDB&gt; show timeseries;</span>
<span class="line">+--------------------+-----+--------+--------+--------+-----------+----+----------+--------+------------------+--------+</span>
<span class="line">|          Timeseries|Alias|Database|DataType|Encoding|Compression|Tags|Attributes|Deadband|DeadbandParameters|ViewType|</span>
<span class="line">+--------------------+-----+--------+--------+--------+-----------+----+----------+--------+------------------+--------+</span>
<span class="line">|root.db.device.s01  | null| root.db|   INT32|     RLE|     SNAPPY|null|      null|    null|              null|    BASE|</span>
<span class="line">+--------------------+-----+--------+--------+--------+-----------+----+----------+--------+------------------+--------+</span>
<span class="line">|root.db.view.status | null| root.db|   INT32|     RLE|     SNAPPY|null|      null|    null|              null|    VIEW|</span>
<span class="line">+--------------------+-----+--------+--------+--------+-----------+----+----------+--------+------------------+--------+</span>
<span class="line">|root.db.d01.temp01  | null| root.db|   FLOAT|     RLE|     SNAPPY|null|      null|    null|              null|    BASE|</span>
<span class="line">+--------------------+-----+--------+--------+--------+-----------+----+----------+--------+------------------+--------+</span>
<span class="line">|root.db.d01.temp02  | null| root.db|   FLOAT|     RLE|     SNAPPY|null|      null|    null|              null|    BASE|</span>
<span class="line">+--------------------+-----+--------+--------+--------+-----------+----+----------+--------+------------------+--------+</span>
<span class="line">|root.db.d01.avg_temp| null| root.db|   FLOAT|    null|       null|null|      null|    null|              null|    VIEW|</span>
<span class="line">+--------------------+-----+--------+--------+--------+-----------+----+----------+--------+------------------+--------+</span>
<span class="line">Total line number = 5</span>
<span class="line">It costs 0.789s</span>
<span class="line">IoTDB&gt;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The last column <code>ViewType</code> shows the type of the sequence, the time series is BASE and the sequence view is VIEW.</p><p>In addition, some of the sequence view properties will be missing, for example <code>root.db.d01.avg_temp</code> is calculated from temperature averages, so the <code>Encoding</code> and <code>Compression</code> properties are null values.</p><p>In addition, the query results of the <code>SHOW TIMESERIES</code> statement are divided into two main parts.</p><ol><li>information about the timing data, such as data type, compression, encoding, etc.</li><li>other metadata information, such as tag, attribute, database, etc.</li></ol><p>For the sequence view, the temporal data information presented is the same as the original sequence or null (e.g., the calculated average temperature has a data type but no compression method); the metadata information presented is the content of the view.</p><p>To learn more about the view, use <code>SHOW \`\`VIEW</code>. The <code>SHOW \`\`VIEW</code> shows the source of the view&#39;s data, etc.</p><div class="language-Shell line-numbers-mode" data-highlighter="prismjs" data-ext="Shell" data-title="Shell"><pre><code><span class="line">IoTDB&gt; show VIEW root.**;</span>
<span class="line">+--------------------+--------+--------+----+----------+--------+-----------------------------------------+</span>
<span class="line">|          Timeseries|Database|DataType|Tags|Attributes|ViewType|                                   SOURCE|</span>
<span class="line">+--------------------+--------+--------+----+----------+--------+-----------------------------------------+</span>
<span class="line">|root.db.view.status | root.db|   INT32|null|      null|    VIEW|                       root.db.device.s01|</span>
<span class="line">+--------------------+--------+--------+----+----------+--------+-----------------------------------------+</span>
<span class="line">|root.db.d01.avg_temp| root.db|   FLOAT|null|      null|    VIEW|(root.db.d01.temp01+root.db.d01.temp02)/2|</span>
<span class="line">+--------------------+--------+--------+----+----------+--------+-----------------------------------------+</span>
<span class="line">Total line number = 2</span>
<span class="line">It costs 0.789s</span>
<span class="line">IoTDB&gt;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The last column, <code>SOURCE</code>, shows the data source for the sequence view, listing the SQL statement that created the sequence.</p><h5 id="about-data-types" tabindex="-1"><a class="header-anchor" href="#about-data-types"><span>About Data Types</span></a></h5><p>Both of the above queries involve the data type of the view. The data type of a view is inferred from the original time series type of the query statement or alias sequence that defines the view. This data type is computed in real time based on the current state of the system, so the data type queried at different moments may be changing.</p><h2 id="faq" tabindex="-1"><a class="header-anchor" href="#faq"><span>FAQ</span></a></h2><h4 id="q1-i-want-the-view-to-implement-the-function-of-type-conversion-for-example-a-time-series-of-type-int32-was-originally-placed-in-the-same-view-as-other-series-of-type-int64-i-now-want-all-the-data-queried-through-the-view-to-be-automatically-converted-to-int64-type" tabindex="-1"><a class="header-anchor" href="#q1-i-want-the-view-to-implement-the-function-of-type-conversion-for-example-a-time-series-of-type-int32-was-originally-placed-in-the-same-view-as-other-series-of-type-int64-i-now-want-all-the-data-queried-through-the-view-to-be-automatically-converted-to-int64-type"><span>Q1: I want the view to implement the function of type conversion. For example, a time series of type int32 was originally placed in the same view as other series of type int64. I now want all the data queried through the view to be automatically converted to int64 type.</span></a></h4><blockquote><p>Ans: This is not the function of the sequence view. But the conversion can be done using <code>CAST</code>, for example:</p></blockquote><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">CREATE VIEW root.db.device.int64_status</span>
<span class="line">AS </span>
<span class="line">    SELECT CAST(s1, &#39;type&#39;=&#39;INT64&#39;) from root.db.device</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>This way, a query for <code>root.view.status</code> will yield a result of type int64.</p><p>Please note in particular that in the above example, the data for the sequence view is obtained by <code>CAST</code> conversion, so <code>root.db.device.int64_status</code> is not an aliased sequence, and thus <strong>not supported for writing</strong>.</p></blockquote><h4 id="q2-is-default-naming-supported-select-a-number-of-time-series-and-create-a-view-but-i-don-t-specify-the-name-of-each-series-it-is-named-automatically-by-the-database" tabindex="-1"><a class="header-anchor" href="#q2-is-default-naming-supported-select-a-number-of-time-series-and-create-a-view-but-i-don-t-specify-the-name-of-each-series-it-is-named-automatically-by-the-database"><span>Q2: Is default naming supported? Select a number of time series and create a view; but I don&#39;t specify the name of each series, it is named automatically by the database?</span></a></h4><blockquote><p>Ans: Not supported. Users must specify the naming explicitly.</p></blockquote><h4 id="q3-in-the-original-system-create-time-series-root-db-device-s01-you-can-find-that-database-root-db-is-automatically-created-and-device-root-db-device-is-automatically-created-next-deleting-the-time-series-root-db-device-s01-reveals-that-root-db-device-was-automatically-deleted-while-root-db-remained-will-this-mechanism-be-followed-for-creating-views-what-are-the-considerations" tabindex="-1"><a class="header-anchor" href="#q3-in-the-original-system-create-time-series-root-db-device-s01-you-can-find-that-database-root-db-is-automatically-created-and-device-root-db-device-is-automatically-created-next-deleting-the-time-series-root-db-device-s01-reveals-that-root-db-device-was-automatically-deleted-while-root-db-remained-will-this-mechanism-be-followed-for-creating-views-what-are-the-considerations"><span>Q3: In the original system, create time series <code>root.db.device.s01</code>, you can find that database <code>root.db</code> is automatically created and device <code>root.db.device</code> is automatically created. Next, deleting the time series <code>root.db.device.s01</code> reveals that <code>root.db.device</code> was automatically deleted, while <code>root.db</code> remained. Will this mechanism be followed for creating views? What are the considerations?</span></a></h4><blockquote><p>Ans: Keep the original behaviour unchanged, the introduction of view functionality will not change these original logics.</p></blockquote><h4 id="q4-does-it-support-sequence-view-renaming" tabindex="-1"><a class="header-anchor" href="#q4-does-it-support-sequence-view-renaming"><span>Q4: Does it support sequence view renaming?</span></a></h4><blockquote><p>A: Renaming is not supported in the current version, you can create your own view with new name to put it into use.</p></blockquote>`,81))])}const v=t(p,[["render",u],["__file","IoTDB-View_timecho.html.vue"]]),b=JSON.parse('{"path":"/UserGuide/V1.3.0-2/User-Manual/IoTDB-View_timecho.html","title":"View","lang":"en-US","frontmatter":{"description":"View Sequence View Application Background Application Scenario 1 Time Series Renaming (PI Asset Management) In practice, the equipment collecting data may be named with identifi...","head":[["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://iotdb.apache.org/zh/UserGuide/V1.3.0-2/User-Manual/IoTDB-View_timecho.html"}],["meta",{"property":"og:url","content":"https://iotdb.apache.org/UserGuide/V1.3.0-2/User-Manual/IoTDB-View_timecho.html"}],["meta",{"property":"og:site_name","content":"IoTDB Website"}],["meta",{"property":"og:title","content":"View"}],["meta",{"property":"og:description","content":"View Sequence View Application Background Application Scenario 1 Time Series Renaming (PI Asset Management) In practice, the equipment collecting data may be named with identifi..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-11T11:01:16.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-11T11:01:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"View\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-11T11:01:16.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Sequence View Application Background","slug":"sequence-view-application-background","link":"#sequence-view-application-background","children":[]},{"level":2,"title":"Application Scenario 1 Time Series Renaming (PI Asset Management)","slug":"application-scenario-1-time-series-renaming-pi-asset-management","link":"#application-scenario-1-time-series-renaming-pi-asset-management","children":[{"level":3,"title":"Application Scenario 2 Simplifying business layer query logic","slug":"application-scenario-2-simplifying-business-layer-query-logic","link":"#application-scenario-2-simplifying-business-layer-query-logic","children":[]},{"level":3,"title":"Application Scenario 3 Auxiliary Rights Management","slug":"application-scenario-3-auxiliary-rights-management","link":"#application-scenario-3-auxiliary-rights-management","children":[]},{"level":3,"title":"Motivation for designing sequence view functionality","slug":"motivation-for-designing-sequence-view-functionality","link":"#motivation-for-designing-sequence-view-functionality","children":[]}]},{"level":2,"title":"Sequence View Concepts","slug":"sequence-view-concepts","link":"#sequence-view-concepts","children":[{"level":3,"title":"Terminology Concepts","slug":"terminology-concepts","link":"#terminology-concepts","children":[]},{"level":3,"title":"Sequence view","slug":"sequence-view","link":"#sequence-view","children":[]},{"level":3,"title":"Alias Sequences","slug":"alias-sequences","link":"#alias-sequences","children":[]},{"level":3,"title":"Nested Views","slug":"nested-views","link":"#nested-views","children":[]},{"level":3,"title":"Some constraints on sequence views in IoTDB","slug":"some-constraints-on-sequence-views-in-iotdb","link":"#some-constraints-on-sequence-views-in-iotdb","children":[]}]},{"level":2,"title":"Sequence view functionality","slug":"sequence-view-functionality","link":"#sequence-view-functionality","children":[{"level":3,"title":"Creating a view","slug":"creating-a-view","link":"#creating-a-view","children":[]},{"level":3,"title":"View Data Queries","slug":"view-data-queries","link":"#view-data-queries","children":[]},{"level":3,"title":"Modify Views","slug":"modify-views","link":"#modify-views","children":[]},{"level":3,"title":"View Synchronisation","slug":"view-synchronisation","link":"#view-synchronisation","children":[]},{"level":3,"title":"View Metadata Queries","slug":"view-metadata-queries","link":"#view-metadata-queries","children":[]}]},{"level":2,"title":"FAQ","slug":"faq","link":"#faq","children":[]}],"git":{"createdTime":1688958677000,"updatedTime":1731322876000,"contributors":[{"name":"W1y1r","email":"150988475+W1y1r@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":11.73,"words":3518},"filePathRelative":"UserGuide/V1.3.0-2/User-Manual/IoTDB-View_timecho.md","localizedDate":"July 10, 2023","autoDesc":true}');export{v as comp,b as data};
